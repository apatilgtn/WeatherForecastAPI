name: Apigee Deployment Pipeline

trigger: none  # Disable automatic triggers

resources:
  repositories:
    - repository: templates  
      type: git
      name: apigeex-ci-cd 

parameters:
  - name: proxyName
    type: string
    displayName: 'API Proxy Name'
    default: ''
  - name: proxyDirectory
    type: string
    displayName: 'Proxy Directory'
    default: 'apiproxy'
  - name: devEnv
    type: string
    displayName: 'Development Environment'
    default: 'test-env'

variables:
  - group: apigeeX

pool:
  vmImage: 'ubuntu-latest'

stages:
  - stage: Build
    displayName: 'Build and Validate'
    jobs:
      - job: GCP_Auth
        displayName: 'GCP Authentication'
        steps:
          - task: PowerShell@2
            name: authToGCP
            displayName: 'Authenticate to GCP using Service Account'
            inputs:
              targetType: 'inline'
              script: |
                try {
                    Write-Host "Starting GCP Authentication..."
                    
                    # Create the service account JSON file
                    $serviceAccountJsonPath = Join-Path -Path $env:AGENT_TEMPDIRECTORY -ChildPath "service-account.json"
                    Write-Host "Using service account JSON file: $serviceAccountJsonPath"
                    
                    # Write the service account JSON directly to file
                    $env:GCP_SERVICE_ACCOUNT_KEY | Out-File -FilePath $serviceAccountJsonPath -Encoding UTF8 -Force
                    
                    # Verify JSON is valid
                    try {
                        Get-Content $serviceAccountJsonPath -Raw | ConvertFrom-Json
                        Write-Host "Service account JSON is valid"
                    } catch {
                        throw "Invalid service account JSON: $_"
                    }
                    
                    # Set GOOGLE_APPLICATION_CREDENTIALS environment variable
                    $env:GOOGLE_APPLICATION_CREDENTIALS = $serviceAccountJsonPath
                    
                    # Authenticate with GCP using the service account
                    Write-Host "Authenticating with GCP using service account..."
                    gcloud auth activate-service-account --key-file="$serviceAccountJsonPath"
                    
                    if ($LASTEXITCODE -ne 0) {
                        throw "Failed to authenticate with GCP using service account"
                    }
                    
                    # Get and store access token
                    Write-Host "Getting access token..."
                    $accessToken = gcloud auth print-access-token
                    if ([string]::IsNullOrEmpty($accessToken)) {
                        throw "Failed to get access token"
                    }
                    
                    Write-Host "Setting access token as pipeline variable..."
                    Write-Host "##vso[task.setvariable variable=ACCESS_TOKEN;isOutput=true]$accessToken"
                    Write-Host "Authentication successful"
                }
                catch {
                    Write-Error "Authentication failed: $_"
                    Write-Host "##[error]Error details: $($_.Exception.Message)"
                    Write-Host "##[error]Stack trace: $($_.ScriptStackTrace)"
                    exit 1
                }
                finally {
                    # Clean up service account file
                    if (Test-Path -Path $serviceAccountJsonPath) {
                        Remove-Item -Path $serviceAccountJsonPath -Force
                        Write-Host "Cleaned up service account JSON file"
                    }
                }
            env:
              GCP_SERVICE_ACCOUNT_KEY: $(GCP_SERVICE_ACCOUNT_KEY)

          - task: Bash@3
            displayName: 'Verify Authentication'
            inputs:
              targetType: 'inline'
              script: |
                set -e
                echo "Verifying authentication..."
                gcloud auth list
                echo "Verification complete"

      - job: ApigeeLint
        displayName: 'Lint Apigee Proxy'
        dependsOn: GCP_Auth
        steps:
          - task: NodeTool@0
            inputs:
              versionSpec: '20.x'
            displayName: 'Install Node.js'

          - task: Bash@3
            displayName: 'Run Apigee Lint'
            inputs:
              targetType: 'inline'
              script: |
                npm install -g apigeelint
                apigeelint -s ${{ parameters.proxyDirectory }} -f table.js
                
  - stage: Deploy 
    displayName: 'Deploy to Environment'
    dependsOn: Build
    variables:
      ACCESS_TOKEN: $[ stageDependencies.Build.GCP_Auth.outputs['authToGCP.ACCESS_TOKEN'] ]
    jobs:
      - deployment: DeployToDev
        displayName: 'Deploy to Dev'
        environment: development
        variables:
          ACCESS_TOKEN: $[ stageDependencies.Build.GCP_Auth.outputs['authToGCP.ACCESS_TOKEN'] ]
          PROXY_NAME: ${{ parameters.proxyName }}
        strategy:
          runOnce:
            deploy:
              steps:
                - task: Bash@3
                  displayName: 'Install apigeecli'
                  inputs:
                    targetType: 'inline'
                    script: |
                      curl -L https://raw.githubusercontent.com/apigee/apigeecli/main/downloadLatest.sh | sh -
                      echo "##vso[task.prependpath]$HOME/.apigeecli/bin"

                - task: Bash@3
                  displayName: 'Verify Source Directory'
                  inputs:
                    targetType: 'inline'
                    script: |
                      echo "Current directory: $(pwd)"
                      echo "Build.SourcesDirectory: $(Build.SourcesDirectory)"
                      echo "Directory contents:"
                      ls -la $(Build.SourcesDirectory)
                      
                      # Check if proxy directory exists
                      if [ ! -d "$(Build.SourcesDirectory)/apiproxy" ]; then
                        echo "Error: apiproxy directory not found"
                        exit 1
                      fi
                      
                      echo "Proxy directory contents:"
                      ls -la $(Build.SourcesDirectory)/apiproxy

                - task: CopyFiles@2
                  displayName: 'Copy API Proxy Files'
                  inputs:
                    sourceFolder: '$(Build.SourcesDirectory)/apiproxy'
                    contents: '**'
                    targetFolder: '$(Build.ArtifactStagingDirectory)/apiproxy'
                    cleanTargetFolder: true
                    overWrite: true

                - task: ArchiveFiles@2
                  displayName: 'Create API Bundle'
                  inputs:
                    rootFolderOrFile: '$(Build.ArtifactStagingDirectory)/apiproxy'
                    includeRootFolder: true
                    archiveType: 'zip'
                    archiveFile: '$(Build.ArtifactStagingDirectory)/proxy.zip'
                    replaceExistingArchive: true

                - task: Bash@3
                  displayName: 'Verify Bundle'
                  inputs:
                    targetType: 'inline'
                    script: |
                      echo "Checking zip file..."
                      if [ ! -f "$(Build.ArtifactStagingDirectory)/proxy.zip" ]; then
                        echo "Error: Zip file not created"
                        exit 1
                      fi
                      
                      echo "Zip contents:"
                      unzip -l "$(Build.ArtifactStagingDirectory)/proxy.zip"

                - task: Bash@3
                  name: uploadAndDeploy
                  displayName: 'Upload and Deploy Bundle'
                  inputs:
                    targetType: 'inline'
                    script: |
                      # Upload bundle
                      IMPORT_OUTPUT=$(apigeecli apis create bundle \
                        -n "${{ parameters.proxyName }}" \
                        -p "$(Build.ArtifactStagingDirectory)/proxy.zip" \
                        --org "$(APIGEE_ORG)" \
                        --token "$(ACCESS_TOKEN)")
                      
                      # Get revision number
                      LATEST_REVISION=$(echo "$IMPORT_OUTPUT" | grep -oP '"revision": "\K[^"]+')
                      echo "##vso[task.setvariable variable=LATEST_REVISION;isOutput=true]$LATEST_REVISION"
                      
                      # Deploy to environment
                      apigeecli apis deploy \
                        --name "${{ parameters.proxyName }}" \
                        --env "${{ parameters.devEnv }}" \
                        --rev "$LATEST_REVISION" \
                        --org "$(APIGEE_ORG)" \
                        --token "$(ACCESS_TOKEN)" \
                        --ovr
                        
  - stage: PostDeploy
    displayName: 'Cleanup and Summary'
    dependsOn: Deploy
    variables:
      ACCESS_TOKEN: $[ stageDependencies.Build.GCP_Auth.outputs['authToGCP.ACCESS_TOKEN'] ]
      LATEST_REVISION: $[ stageDependencies.Deploy.DeployToDev.outputs['uploadAndDeploy.LATEST_REVISION'] ]
    jobs:
      - job: CleanupRevisions
        displayName: 'Cleanup Old Revisions'
        variables:
          PROXY_NAME: ${{ parameters.proxyName }}
        steps:
          - task: Bash@3
            name: cleanup
            displayName: 'Delete Older Revisions'
            inputs:
              targetType: 'inline'
              script: |
                echo "Starting cleanup of old revisions..."
                
                # Install apigeecli if not already installed
                if ! command -v apigeecli &> /dev/null; then
                  curl -L https://raw.githubusercontent.com/apigee/apigeecli/main/downloadLatest.sh | sh -
                  echo "##vso[task.prependpath]$HOME/.apigeecli/bin"
                fi
                
                # Get all revisions
                REVISIONS=$(apigeecli apis list revisions \
                  --name "$PROXY_NAME" \
                  --org "$(APIGEE_ORG)" \
                  --token "$(ACCESS_TOKEN)" \
                  --disable-check)
                
                # Convert to array and sort
                REVISION_ARRAY=($(echo $REVISIONS | tr ',' '\n' | sort -n))
                TOTAL_REVISIONS=${#REVISION_ARRAY[@]}
                
                # Keep the latest 5 revisions
                KEEP_COUNT=5
                DELETE_COUNT=0
                FAILED_COUNT=0
                
                if [ $TOTAL_REVISIONS -gt $KEEP_COUNT ]; then
                  # Calculate how many to delete
                  TO_DELETE=$((TOTAL_REVISIONS - KEEP_COUNT))
                  
                  for ((i=0; i<$TO_DELETE; i++)); do
                    REV="${REVISION_ARRAY[$i]}"
                    echo "Checking revision $REV..."
                    
                    # Check if revision is deployed
                    DEPLOYMENT_STATUS=$(apigeecli apis list deployments \
                      --name "$PROXY_NAME" \
                      --org "$(APIGEE_ORG)" \
                      --token "$(ACCESS_TOKEN)" \
                      --rev "$REV" \
                      --disable-check)
                    
                    if [[ $DEPLOYMENT_STATUS == *"not deployed"* ]]; then
                      echo "Deleting revision $REV..."
                      if apigeecli apis delete revision \
                        --name "$PROXY_NAME" \
                        --org "$(APIGEE_ORG)" \
                        --token "$(ACCESS_TOKEN)" \
                        --rev "$REV" \
                        --disable-check; then
                        ((DELETE_COUNT++))
                        echo "Successfully deleted revision $REV"
                      else
                        ((FAILED_COUNT++))
                        echo "Failed to delete revision $REV"
                      fi
                    else
                      echo "Skipping deployed revision $REV"
                    fi
                  done
                fi
                
                # Set output variables
                echo "##vso[task.setvariable variable=KEPT_COUNT;isOutput=true]$KEEP_COUNT"
                echo "##vso[task.setvariable variable=DELETED_COUNT;isOutput=true]$DELETE_COUNT"
                echo "##vso[task.setvariable variable=FAILED_COUNT;isOutput=true]$FAILED_COUNT"
                echo "##vso[task.setvariable variable=TOTAL_REVISIONS;isOutput=true]$TOTAL_REVISIONS"

      - job: DeploymentSummary
        displayName: 'Generate Deployment Summary'
        dependsOn: CleanupRevisions
        variables:
          KEPT_COUNT: $[ dependencies.CleanupRevisions.outputs['cleanup.KEPT_COUNT'] ]
          DELETED_COUNT: $[ dependencies.CleanupRevisions.outputs['cleanup.DELETED_COUNT'] ]
          FAILED_COUNT: $[ dependencies.CleanupRevisions.outputs['cleanup.FAILED_COUNT'] ]
          TOTAL_REVISIONS: $[ dependencies.CleanupRevisions.outputs['cleanup.TOTAL_REVISIONS'] ]
        steps:
          - task: PowerShell@2
            displayName: 'Generate Summary'
            inputs:
              targetType: 'inline'
              script: |
                $deploymentTime = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                
                $summaryContent = @"
                # Apigee Deployment Summary
                
                ## Deployment Details
                - **API Proxy**: ${{ parameters.proxyName }}
                - **Environment**: ${{ parameters.devEnv }}
                - **Latest Revision**: $(LATEST_REVISION)
                - **Deployment Time**: $deploymentTime
                
                ## Cleanup Results
                - **Total Revisions**: $(TOTAL_REVISIONS)
                - **Revisions Kept**: $(KEPT_COUNT)
                - **Revisions Deleted**: $(DELETED_COUNT)
                - **Failed Deletions**: $(FAILED_COUNT)
                
                ## Pipeline Information
                - **Run ID**: $(Build.BuildId)
                - **Pipeline**: $(Build.DefinitionName)
                - **Triggered by**: $(Build.RequestedFor)
                - **Branch**: $(Build.SourceBranch)
                
                ## Environment Status
                - **Status**: Deployment Successful
                - **Environment**: ${{ parameters.devEnv }}
                - **Organization**: $(APIGEE_ORG)
                "@
                
                $summaryContent | Out-File -FilePath "$(Build.ArtifactStagingDirectory)/deployment-summary.md" -Encoding UTF8

          - task: PublishBuildArtifacts@1
            condition: always()
            inputs:
              pathToPublish: '$(Build.ArtifactStagingDirectory)/deployment-summary.md'
              artifactName: 'DeploymentSummary'