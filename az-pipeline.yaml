name: Apigee Deployment Pipeline

trigger: none  # Disable automatic triggers

resources:
  repositories:
    - repository: templates  
      type: git
      name: apigeex-ci-cd 

parameters:
  - name: proxyName
    type: string
    displayName: 'API Proxy Name'
    default: ''
  - name: proxyDirectory
    type: string
    displayName: 'Proxy Directory'
    default: 'apiproxy'
  - name: devEnv
    type: string
    displayName: 'Development Environment'
    default: 'test-env'
  - name: testEnv
    type: string
    displayName: 'Test Environment'
    default: 'test'
  - name: uatEnv
    type: string
    displayName: 'UAT Environment'
    default: 'uat'

variables:
  - group: apigeeX

pool:
  vmImage: 'ubuntu-latest'

stages:
  - stage: Build
    displayName: 'Build and Validate'
    jobs:
      - job: GCP_Auth
        displayName: 'GCP Authentication'
        steps:
          - task: PowerShell@2
            name: authToGCP
            displayName: 'Authenticate to GCP using Service Account'
            inputs:
              targetType: 'inline'
              script: |
                try {
                    Write-Host "Starting GCP Authentication..."
                    
                    # Create the service account JSON file
                    $serviceAccountJsonPath = Join-Path -Path $env:AGENT_TEMPDIRECTORY -ChildPath "service-account.json"
                    Write-Host "Using service account JSON file: $serviceAccountJsonPath"
                    
                    # Decode the base64 service account key and save it to file
                    $serviceAccountJson = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($env:GCP_SERVICE_ACCOUNT_KEY))
                    $serviceAccountJson | Out-File -FilePath $serviceAccountJsonPath -Encoding UTF8 -Force
                    
                    # Verify JSON is valid
                    try {
                        $null = $serviceAccountJson | ConvertFrom-Json
                        Write-Host "Service account JSON is valid"
                    } catch {
                        throw "Invalid service account JSON: $_"
                    }
                    
                    # Set GOOGLE_APPLICATION_CREDENTIALS environment variable
                    $env:GOOGLE_APPLICATION_CREDENTIALS = $serviceAccountJsonPath
                    
                    # Authenticate with GCP using the service account
                    Write-Host "Authenticating with GCP using service account..."
                    gcloud auth activate-service-account --key-file="$serviceAccountJsonPath"
                    
                    if ($LASTEXITCODE -ne 0) {
                        throw "Failed to authenticate with GCP using service account"
                    }
                    
                    # Get and store access token
                    Write-Host "Getting access token..."
                    $accessToken = gcloud auth print-access-token
                    if ([string]::IsNullOrEmpty($accessToken)) {
                        throw "Failed to get access token"
                    }
                    
                    Write-Host "Setting access token as pipeline variable..."
                    Write-Host "##vso[task.setvariable variable=ACCESS_TOKEN;isOutput=true]$accessToken"
                    Write-Host "Authentication successful"
                }
                catch {
                    Write-Error "Authentication failed: $_"
                    Write-Host "##[error]Error details: $($_.Exception.Message)"
                    Write-Host "##[error]Stack trace: $($_.ScriptStackTrace)"
                    exit 1
                }
                finally {
                    # Clean up service account file
                    if (Test-Path -Path $serviceAccountJsonPath) {
                        Remove-Item -Path $serviceAccountJsonPath -Force
                        Write-Host "Cleaned up service account JSON file"
                    }
                }
            env:
              GCP_SERVICE_ACCOUNT_KEY: $(GCP_SERVICE_ACCOUNT_KEY)

          - task: Bash@3
            displayName: 'Verify Authentication'
            inputs:
              targetType: 'inline'
              script: |
                set -e
                echo "Verifying authentication..."
                gcloud auth list
                echo "Verification complete"

      - job: ApigeeLint
        displayName: 'Lint Apigee Proxy'
        dependsOn: GCP_Auth
        steps:
          - task: NodeTool@0
            inputs:
              versionSpec: '20.x'
            displayName: 'Install Node.js'

          - task: Bash@3
            displayName: 'Run Apigee Lint'
            inputs:
              targetType: 'inline'
              script: |
                npm install -g apigeelint
                apigeelint -s ${{ parameters.proxyDirectory }} -f table.js

  - stage: Prepare
    displayName: 'Prepare Bundle'
    dependsOn: Build
    jobs:
      - job: PrepareAndUpload
        displayName: 'Prepare and Upload Bundle'
        variables:
          ACCESS_TOKEN: $[ stageDependencies.Build.GCP_Auth.outputs['authToGCP.ACCESS_TOKEN'] ]
        steps:
          - task: Bash@3
            displayName: 'Install apigeecli'
            inputs:
              targetType: 'inline'
              script: |
                curl -L https://raw.githubusercontent.com/apigee/apigeecli/main/downloadLatest.sh | sh -
                echo "##vso[task.prependpath]$HOME/.apigeecli/bin"

          - task: ArchiveFiles@2
            displayName: 'Create API Bundle'
            inputs:
              rootFolderOrFile: '$(Build.SourcesDirectory)/${{ parameters.proxyDirectory }}'
              includeRootFolder: false
              archiveType: 'zip'
              archiveFile: '$(Build.ArtifactStagingDirectory)/proxy.zip'

          - task: Bash@3
            name: uploadBundle
            displayName: 'Upload and Get Revision'
            inputs:
              targetType: 'inline'
              script: |
                IMPORT_OUTPUT=$(apigeecli apis create bundle \
                  -n "${{ parameters.proxyName }}" \
                  -p "$(Build.ArtifactStagingDirectory)/proxy.zip" \
                  --org "$(APIGEE_ORG)" \
                  --token "$(ACCESS_TOKEN)")
                
                LATEST_REVISION=$(echo "$IMPORT_OUTPUT" | grep -oP '"revision": "\K[^"]+')
                echo "##vso[task.setvariable variable=LATEST_REVISION;isOutput=true]$LATEST_REVISION"

  - stage: Deploy 
    displayName: 'Deploy to Environments'
    dependsOn: Prepare
    jobs:
      - deployment: DeployToDev
        displayName: 'Deploy to Dev'
        environment: development
        variables:
          ACCESS_TOKEN: $[ stageDependencies.Build.GCP_Auth.outputs['authToGCP.ACCESS_TOKEN'] ]
          LATEST_REVISION: $[ stageDependencies.Prepare.PrepareAndUpload.outputs['uploadBundle.LATEST_REVISION'] ]
        strategy:
          runOnce:
            deploy:
              steps:
                - template: templates/deploy-steps.yml@templates
                  parameters:
                    environmentName: ${{ parameters.devEnv }}

      - deployment: DeployToTest
        displayName: 'Deploy to Test'
        dependsOn: DeployToDev
        environment: test
        variables:
          ACCESS_TOKEN: $[ stageDependencies.Build.GCP_Auth.outputs['authToGCP.ACCESS_TOKEN'] ]
          LATEST_REVISION: $[ stageDependencies.Prepare.PrepareAndUpload.outputs['uploadBundle.LATEST_REVISION'] ]
        strategy:
          runOnce:
            deploy:
              steps:
                - template: templates/deploy-steps.yml@templates
                  parameters:
                    environmentName: ${{ parameters.testEnv }}

      - deployment: DeployToUat
        displayName: 'Deploy to UAT'
        dependsOn: DeployToTest
        environment: uat
        variables:
          ACCESS_TOKEN: $[ stageDependencies.Build.GCP_Auth.outputs['authToGCP.ACCESS_TOKEN'] ]
          LATEST_REVISION: $[ stageDependencies.Prepare.PrepareAndUpload.outputs['uploadBundle.LATEST_REVISION'] ]
        strategy:
          runOnce:
            deploy:
              steps:
                - template: templates/deploy-steps.yml@templates
                  parameters:
                    environmentName: ${{ parameters.uatEnv }}

  - stage: Cleanup
    displayName: 'Cleanup and Summary'
    dependsOn: Deploy
    jobs:
      - job: CleanupRevisions
        displayName: 'Cleanup Old Revisions'
        variables:
          ACCESS_TOKEN: $[ stageDependencies.Build.GCP_Auth.outputs['authToGCP.ACCESS_TOKEN'] ]
        steps:
          - task: Bash@3
            name: cleanup
            displayName: 'Delete Older Revisions'
            inputs:
              targetType: 'inline'
              script: |
                # Your existing cleanup script here

      - job: DeploymentSummary
        displayName: 'Generate Deployment Summary'
        dependsOn: CleanupRevisions
        variables:
          LATEST_REVISION: $[ stageDependencies.Prepare.PrepareAndUpload.outputs['uploadBundle.LATEST_REVISION'] ]
          KEPT_COUNT: $[ dependencies.CleanupRevisions.outputs['cleanup.KEPT_COUNT'] ]
          DELETED_COUNT: $[ dependencies.CleanupRevisions.outputs['cleanup.DELETED_COUNT'] ]
          FAILED_COUNT: $[ dependencies.CleanupRevisions.outputs['cleanup.FAILED_COUNT'] ]
        steps:
          - task: PowerShell@2
            displayName: 'Generate Summary'
            inputs:
              targetType: 'inline'
              script: |
                # Your existing summary generation script here

          - task: PublishBuildArtifacts@1
            condition: always()
            inputs:
              pathToPublish: '$(Build.ArtifactStagingDirectory)/deployment-summary.md'
              artifactName: 'DeploymentSummary'